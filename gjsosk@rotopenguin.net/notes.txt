Hmmm.
https://wayland-book.com/seat/keyboard.html
I knew that modifier-flags was a thing separate from just sending "LALT DEPRESSED" events. AFAICT, Clutter does not expose anything to let you send a modifier-flags message. 

Structure of keys.
KeyBtn is a ST.Button. Keyboard.keys is an array of em. AKA "item" at times.
     .char is a {code:int, layers.{default,numlock,...}} from the keycodes/cc.json file. 
        .code:int
        .layers
            .default = "a" or some such letter
            .shift = "A" 
            numlock capslock alt numcapslock shiftcapslock altshift altnumlock shiftnumlock altcapslock shiftnumcapslock altshiftcapslock altshiftnumlock altnumcapslock altshiftnumcapslock       
         .isMod:bool 
     .keydef (I just added it) is the physicalLayouts.json struct.
        .key = string scancode (particularly stuff like "AB01" through "AE12" for the qwerty/azerty grid. Other keys have sensible names like "ESC" or "RCTL" )
        .width = default 1
        .repeat:bool should the ST.Button press/releases be directly turned into Clutter.PRESS/RELEASE, with minimal participation in the rest of the keyboard's state machine?
   .key_pressed:bool have I sent a PRESSED notify without a corresponding RELEASED?
   .holdFnDidActivate:bool 
   .holdFnDelayTimer:()=>{closure} if release happens before expiring, act normally. If it does expire, do your holdFn instead.
   .lastPressTime:int hmmmmm
   .myKeyboard - the Keyboard that you belong to.


Does releaseEv() happen if the keyboard's focus is somehow lost? Do I have to make a key-up happen myself? The decideMod/sendKey path assumes that a keypress is just a quick poke (seperated by a delayed callback.) 

Clutter.get_default_backend().get_default_seat().create_virtual_device(Clutter.InputDeviceType.KEYBOARD_DEVICE) ->  metaVirtualInputDeviceNative.
meta_virtual_input_device_native_class_init() is where everything that GIR can see lives.

ModifierType is where clutter keeps a modifier state. Still unable to find any gir setter that goes near it.

One trick to release Alt without setting off the "tap alt to move focus to the _F_ile menu" would be to briefly tap another modifier key just before releasing Alt. 

How do I want "modifiers" to work? 
   I think I want a brief tap to mean "it is locked until the next non-mod is pressed". Should that key truly be held down the entire time? 
   Quick double-tap means "lock it until it is tapped again (and inhibit weird side effects like tapping alt for menu).
   Tap, then tap again with no other key intervening - let actions like "alt for menu" and "win for overview" happen.
   Double-tap lock one modifier, while another is in single-tap lock. Or vice versa. Don't know what I want here.
   Hold space to enable horizontal scrolly mode (it just taps L/R arrow) - immediately cancel all modifiers.
   I think I want the rank-and-file keys to repeat, unless there is a modifier in play. 

Other Todo: 
   Deal with the enormous mess pooped into the journal as gnome-shell shuts down.
   Rewrite buildUI.
   Look at the whole top 50% of the extension. There are probably dragons in the enable stuff.
   Make a crappy .gjs text editor that can use the keyboard standalone?? Won't have to bounce the whole compositor to test stuff anymore.
   CSS to switch between keyboard layers? To manage transitions?? I dunno if it can automagically propogate changes.
      On second thought, I think the advanced CSS stuff is only in GTK, not ST.


Getting caught up on 9mo of changes upstream...

DID 850de32 Don't refresh the keyboard if no monitors are present at 'monitors-changed' event
Skip 900ccf6 Check for current keymap json existing
   This also steps into the whole "extract tar.gz" mess, which I snipped. Yuck.
Skip 8818655 Add custom tap sounds
TODO cd9d7a2 Fallback to default monitor if defined monitor isn't available (hopefully fixes # 112)
Skip 982e962 Disable auto-open when keyboard toggle is disabled in Quick Settings.
   HMM I think I want less of this settings-itis.
83dc9a2 Fix rescaling keyboard upon opening access dialog # 117
97b05fe Attempt to add much more robust extraction funcionality (hopefully fixes # 113)
   STAHP. The extension shouldn't be extracting a tarball. That should have already been taken care of by "installing the extension in the first place".
04f91de Add a schema to track whether the keyboard is open (fixes # 104)
   Hmm, may circle back around to this one. ðŸ˜º
253a8d1 Make standardization changes with pre-45 branch
   changing .hasOwn() into 'in' operator. Uhh I'd have to know more JS for this. ðŸ˜º
7e291a5 Test extra updates for GNOME 49 Compatibility
   a bunch of stuff for edgeDragAction. Eh.
d159bf3 Typo
   An edgedragaction thing.
a0782c3 Why is Shell.EdgDragGesture a Final type?
e7718f6 More attempts
   meh edge
15461a8 Submit to the confines of GNOME
   edge 
a398525 Try adding it a different way
   edge
a962d70 Successfully fix gnome 49 compatibility (fixes # 118)
   oh oh, this stuff might become important. ðŸ˜º 
13c7315 Properly error out if the keyboard doesn't initalize
   looks like a good patch to pick up. ðŸ˜º 
c360c13 Attempt to account for delayed monitor start 
   uhh this is a lot ðŸ˜º
fd51c37 fix: prevent systemd log flooding
   I think I have chopped out everything he's doing here. Move handles? Gone! Key state logic? TERMINATED.
310f1b3 Merge remote-tracking branch 'fix-logging/fix/issue-116-logging'
   Repeat.
1854994 Fix all logging issues (credits to @thomas-bp) (should resolve # 116)
   May need to look at the SafeKeyboard stuff...
DID 6cf7640 More excess logging fixes
   does a signal_handler_is_connected check before various keymap.disconnect actions.

... keep moving up https://github.com/Vishram1123/gjs-osk/commits/main/gjsosk%40vishram1123.com/extension.js